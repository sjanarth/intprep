This is how I feel about the difficulty:
* = only for practice. 
** = easy real interview problem (e.g. for warm-up)
*** = full real interview problem
Also note that many of the * problems should use a loop instead of recursion in real code.
1.) Compute the length of a linked list 
    Difficulty: *
    Example:
      Input: [4,-6,2] 
      Length: 3
2.) Filter a linked list so that negative numbers are removed
    Difficulty: *
    Example:
      Input: [1,-3,4,2,-6,3] 
      Result: [1,4,2,3]
3.) Compute the sum of all numbers stored in a linked list
    Difficulty: *
    Example:
      Input: [3,6,1,2] 
      Sum: 12
4.) "Zip" two linked lists, so that the nodes in the result list contain the sum of the nodes in the two input lists
    Difficulty: *
    Example:
      Input A: [1,3,9,4]
      Input B: [4,9,2,2]
      Result: [5,12,11,6] 
      Explanation: [5=1+4,12=3+9,11=9+2,6=4+2]
5.) "Zip" two linked lists, so that the result list contains one node from list A, followed by one node from list B, followed by one node from list A, and so on. If you want to make this harder, try to only use one "if statement" to detect the base case (end of the lists), but don't use "if" anywhere else.
    Difficulty: **
    Example:
      Input A: [2,2,2,2]
      Input B: [8,8,8,8]
      Result: [2,8,2,8,2,8,2,8]
6.) Reverse a linked list
    Difficulty: **
    Hint: Use an aggregation parameter
    Example:
      Input: [3,4,2]
      Result: [2,4,3]
7.) "Flatten" a linked list, so that nodes of nested linked lists become part of the top level 
    Difficulty: **
    Note: For statically typed languages like Java or C++ assume that the input list is nested exactly two levels deep:
    class IntListNode {
      int value;
      IntListNode next;
    }
    class NestedListNode {
      IntListNode innerList;
      NestedListNode next;
    }
    Example:
      Input: [[3,4],[5,6,7],[8]]
      Result: [3,4,5,6,7,8]
8.) "Fold" or "Reduce" a linked list. Optionally, pass in a "neutral element" as a tird parameter, e.g. "1" for multiplication, or "0" for addition.
    Difficulty: *
    Example:
      Input list: [2,3,5]
      Input function: (a,b) => a*b
      Neutral element (optional): 1
      Result: 30
      Explanation: 
        (2*(3*5)) = 30 -- ((2*3)*5) would also be correct
        Computation with neutral element: (2*(3*(5*1))) or (((2*3)*5)*1)
9.) Split a linked list, so that all nodes with negative numbers land in list A and the other nodes in list B
    Difficulty: *
    Example:
      Input: [3,-4,2,6,-7]
      Result A: [-4,-7]
      Result B: [3,2,6]
10.) Return the first N elements from the beginning of a linked list
     Difficulty: *
     Example:
       Input List: [1,2,3,4,5,6]
       Input N: 3
       Result: [1,2,3]
11.) Return those nodes from a linked list that correspond to "1" bits in a given bit pattern
     Difficulty: **
     Example:
       Input list: [1,2,3,4,5,6]
       Input bit pattern: 19
       Result: [1,2,5]
       Explanation: 19 in binary is: 10011, i.e. reading from the right, the bits at these positions are set: 1,2,5
12.) Return the longest string from a linked list of strings. Only go through the list once.
     Difficulty: *
     Example:
       Input: ['The', 'lazy', 'dog', 'jumps', 'over', 'the', 'fox']
       Result: 'jumps'
13.) Implement "all": For a linked list of booleans return 'true' if and only if all nodes in the list are 'true'
     Difficulty: *
     Example:
       Input: [true, true, false, true]
       Result: false
14.) Replicate the elements of a list N times. Try to code this fully recursive without any loop.
     Difficulty: **
     Example:
       Input list: [1,2,3,4]
       Input N: 3
       Result: [1,1,1,2,2,2,3,3,3,4,4,4]
15.) Run length encoding: If two adjecent linked list nodes have the same value, store them as a tuple of value, and number of repetitions. Don't use any loops.
     Difficulty: **
     Note: If your language doesn't have a tuple type, use linked lists definitions like these:
     class DecodedListNode {
        String value;
        DecodedListNode next;
     }
     class EncodedListNode {
       String value;
       int repititions;
       EncodedListNode next;
     }   
     Example: 
       Input: ['A','A','A','B','C','C','C','C','D','D']
       Result: [('A',3), ('B',1), ('C',4), ('D',2)]
16.) Run length decoding: Implement the reverse of the previous problem. Don't use any loops.
     Difficulty: **
     Example: 
       Input: [('A',3), ('B',1), ('C',4), ('D',2)]
       Result: ['A','A','A','B','C','C','C','C','D','D']
17.) Remove every N-th element from a linked list.
     Difficulty: **
     Example:
       Input list: [1,2,3,4,5,6,7,8]
       Input N: 3
       Result: [1,2,4,5,7,8]
18.) Running average. Compute the running average of every N nodes of a list. Have your recursive function only go through the list once.
     Difficulty: ***
     Example:
       Input list: [1,3,2,10,6,5,1]
       Input N: 3  
       Result: [2,5,6,7,4]
       Explanation:  (1+3+2)/3 = 2, (3+2+10)/3 = 5, (2+10+6)/3 = 6, (10+6+5)/3 = 7, (6+5+1)/3 = 4
19.) For an array of nouns, and an array of verbs, print out all possible "noun, verb, noun"-sentences.
     Difficulty: **
     Example:
       Input nouns: ["the dog", "a fox"]
       Input verbs: ["sees", "hears"]
       Output:
         the dog sees the dog
         the dog sees a fox
         the dog hears the dog
         the dog hears a fox
         a fox sees the dog
         a fox sees a fox
         a fox hears the dog
         a fox hears a fox
20.) For an arrays of numbers, print out all combinations of two elements from the array that sum up to an element in the array. This is harder if you don't reuse the same element.
     Difficulty: **
     Example:
       Input: [2,1,4,3]
       Output:
         2+1=3
         1+2=3
         1+3=4
         3+1=4
       Notes: 
         2+2=4 would be invalid, because it reuses 2
         4+3=7 would be invalid, because 7 is not in the array
21.) A triangle of numbers is given as a list of lists, where the first inner list has one element, the second inner list has two elements, and each subsequent inner list has one element more than the list before. Find the path from top to bottom in that triangle which sums up to the largest value. Use arrays instead of lists, if that is more convenient in your language.
     Difficulty: *** 
     Note: There is also a much faster non-recursive solution using two nested loops, that I don't asked for here.
     Example: 
       Input: [[1],[4,3],[2,1,5]]
       Result: 9
       Explanation: 
         The input stands for the following triangle (which is NOT a tree):
             1
            / \
           4   3
          / \ / \
         2   1   5
         
         The four paths through this triangle have these sums:
           1+4+2=7
           1+4+1=6
           1+3+1=5
           1+3+5=9
         Of which "9" is the largest.
22.) Given a list of words and a target word, print all ways in which the words from the list can be aligned so that the target word can be read top to bottom.
     Difficulty: ***
     Hint 1: Have the function compute the number of spaces to print before every entry.
     Hint 2: Can you transform the list of words to a different representation so that you don't have to deal with strings in the recursive function? 
     Example:
       Input list: ['biber', 'eagle', 'hare', 'horse']
       Input target: 'bear'
       Output: (Capitalization is optional)
         |  Biber
         |  Eagle
         | hAre
         |hoRse
         |
         |biBer
         |  Eagle
         | hAre
         |hoRse
         |
         |    Biber
         |eaglE
         |   hAre
         |  hoRse
         |
         |  biBer
         |eaglE
         |   hAre
         |  hoRse
